import schedule from "node-schedule";
import chalk from "chalk";
import { MessageMention } from "zlbotdqt";
import { extendMuteDuration } from "./mute-user.js";
import { isInWhiteList } from "./white-list.js";
import { sendMessageStateQuote } from "../chat-zalo/chat-style/chat-style.js";
import { removeMention } from "../../utils/format-util.js";
import { getAntiState, updateAntiConfig } from "./index.js";

// H√†m ki·ªÉm tra t·ª´ c·∫•m
function checkBadWords(content) {
  let badWords = getAntiState()?.data?.badWords || [];
  const normalizedContent = normalizeText(content);
  const words = normalizedContent.split(/\s+/);

  for (const badWord of badWords) {
    const normalizedBadWord = normalizeText(badWord);

    // Ki·ªÉm tra t·ª´ng t·ª´ ri√™ng bi·ªát
    for (const word of words) {
      if (word === normalizedBadWord) {
        return {
          found: true,
          word: badWord,
        };
      }
    }

    // Ki·ªÉm tra c·ª•m t·ª´ trong n·ªôi dung
    if (normalizedBadWord.includes(" ")) {
      if (normalizedContent.includes(normalizedBadWord)) {
        return {
          found: true,
          word: badWord,
        };
      }
    }
  }

  return {
    found: false,
    word: null,
  };
}

async function handleBadWordModification(api, message, action, word) {
  const threadId = message.threadId;

  if (!word) {
    await api.sendMessage(
      {
        msg: `Vui l√≤ng nh·∫≠p t·ª´ kh√≥a c·∫ßn ${action === "add" ? "th√™m" : "x√≥a"}`,
        quote: message,
      },
      threadId,
      message.type
    );
    return;
  }

  const antiState = getAntiState();
  const currentBadWords = [...antiState.data.badWords]; // T·∫°o b·∫£n sao c·ªßa m·∫£ng hi·ªán t·∫°i

  if (action === "add") {
    if (!currentBadWords.includes(word)) {
      currentBadWords.push(word);
      updateAntiConfig({
        ...antiState.data,
        badWords: currentBadWords
      });
      
      // C·∫≠p nh·∫≠t bi·∫øn local
      badWords = currentBadWords;

      await api.sendMessage(
        {
          msg: `ƒê√£ th√™m "${word}" v√†o danh s√°ch t·ª´ c·∫•m`,
          quote: message,
          ttl: 30000,
        },
        threadId,
        message.type
      );
    } else {
      await api.sendMessage(
        {
          msg: `T·ª´ "${word}" ƒë√£ c√≥ trong danh s√°ch t·ª´ c·∫•m`,
          quote: message,
          ttl: 30000,
        },
        threadId,
        message.type
      );
    }
  } else if (action === "remove") {
    const index = currentBadWords.indexOf(word);
    if (index !== -1) {
      currentBadWords.splice(index, 1);
      updateAntiConfig({
        ...antiState.data,
        badWords: currentBadWords
      });

      // C·∫≠p nh·∫≠t bi·∫øn local
      badWords = currentBadWords;

      await api.sendMessage(
        {
          msg: `ƒê√£ x√≥a "${word}" kh·ªèi danh s√°ch t·ª´ c·∫•m`,
          quote: message,
          ttl: 30000,
        },
        threadId,
        message.type
      );
    } else {
      await api.sendMessage(
        {
          msg: `ƒê√©o t√¨m th·∫•y "${word}" trong danh s√°ch t·ª´ c·∫•m`,
          quote: message,
          ttl: 30000,
        },
        threadId,
        message.type
      );
    }
  }
}

// Th√™m h√†m m·ªõi ƒë·ªÉ hi·ªÉn th·ªã danh s√°ch t·ª´ c·∫•m
async function showBadWordsList(api, message) {
  const threadId = message.threadId;
  try {
    const antiState = getAntiState();
    const wordsList = antiState.data.badWords.map((pattern) => {
      return pattern
        .replace(/\\b/g, "")
        .replace(/\+/g, "")
        .replace(/\\/g, "")
        .replace(/\*/g, " ");
    });

    if (wordsList.length === 0) {
      await api.sendMessage(
        {
          msg: "Hi·ªán t·∫°i ch∆∞a c√≥ t·ª´ ng·ªØ n√†o b·ªã c·∫•m.",
          quote: message,
        },
        threadId,
        message.type
      );
      return;
    }

    const formattedList = wordsList.map((word) => `${word}`).join(", ");
    await api.sendMessage(
      {
        msg: `üìù Danh s√°ch t·ª´ ng·ªØ b·ªã c·∫•m (${wordsList.length} t·ª´):\n[${formattedList}]\n\nüí° D√πng l·ªánh:\n- !antibadword add [t·ª´] ƒë·ªÉ th√™m\n- !antibadword remove [t·ª´] ƒë·ªÉ x√≥a`,
        quote: message,
        ttl: 30000,
      },
      threadId,
      message.type
    );
  } catch (error) {
    console.error("L·ªói khi ƒë·ªçc danh s√°ch t·ª´ c·∫•m:", error);
    await api.sendMessage(
      {
        msg: "ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc danh s√°ch t·ª´ c·∫•m.",
        quote: message,
        ttl: 30000,
      },
      threadId,
      message.type
    );
  }
}

// C·∫≠p nh·∫≠t h√†m handleAntiBadWordCommand ƒë·ªÉ th√™m l·ªánh list
export async function handleAntiBadWordCommand(api, message, groupSettings) {
  const content = removeMention(message);
  const threadId = message.threadId;
  const args = content.split(" ");
  const command = args[1]?.toLowerCase();

  if (!groupSettings[threadId]) {
    groupSettings[threadId] = {};
  }

  // Th√™m case x·ª≠ l√Ω l·ªánh list
  if (command === "list") {
    await showBadWordsList(api, message);
    return true;
  }

  if (command === "show") {
    await showViolationHistory(api, message, threadId);
    return true;
  }

  if (command === "add" || command === "remove") {
    const word = args.slice(2).join(" ");
    await handleBadWordModification(api, message, command, word);
    return true;
  }

  if (command === "on") {
    groupSettings[threadId].filterBadWords = true;
  } else if (command === "off") {
    groupSettings[threadId].filterBadWords = false;
  } else {
    groupSettings[threadId].filterBadWords =
      !groupSettings[threadId].filterBadWords;
  }

  const newStatus = groupSettings[threadId].filterBadWords ? "b·∫≠t" : "t·∫Øt";
  const caption = `Ch·ª©c nƒÉng l·ªçc t·ª´ kh√≥a th√¥ t·ª•c ƒë√£ ƒë∆∞·ª£c ${newStatus}!`;
  await sendMessageStateQuote(
    api,
    message,
    caption,
    groupSettings[threadId].filterBadWords,
    300000
  );
  return true;
}

// H√†m chu·∫©n h√≥a vƒÉn b·∫£n
function normalizeText(text) {
  return (
    text
      .toLowerCase()
      // .replace(/[√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ]/g, "a")
      // .replace(/[√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ]/g, "e")
      // .replace(/[√¨√≠·ªã·ªâƒ©]/g, "i")
      // .replace(/[√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°]/g, "o")
      // .replace(/[√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ]/g, "u")
      // .replace(/[·ª≥√Ω·ªµ·ª∑·ªπ]/g, "y")
      // .replace(/ƒë/g, "d")
      // .replace(/\s+/g, " ")
      .trim()
  );
}

// H√†m l∆∞u vi ph·∫°m
async function saveViolation(threadId, userId, userName, badWord) {
  const antiState = getAntiState();
  const violations = antiState.data.violations || {};
  
  if (!violations[threadId]) {
    violations[threadId] = {};
  }

  if (!violations[threadId][userId]) {
    violations[threadId][userId] = {
      count: 0,
      words: [],
      name: userName
    };
  }

  violations[threadId][userId].count++;
  violations[threadId][userId].words.push({
    word: badWord,
    time: Date.now()
  });

  if (violations[threadId][userId].words.length > 3) {
    violations[threadId][userId].words = 
      violations[threadId][userId].words.slice(-3);
  }

  updateAntiConfig({
    ...antiState.data,
    violations
  });

  return violations[threadId][userId];
}

export async function antiBadWord(
  api,
  message,
  groupSettings,
  isAdminBox,
  botIsAdminBox,
  isSelf
) {
  if (isSelf) return false;
  let content = message.data.content;
  content = content.title ? content.title : content;
  const threadId = message.threadId;
  const senderId = message.data.uidFrom;
  const isPlainText = typeof content === "string";

  if (isPlainText && groupSettings[threadId]?.filterBadWords) {
    if (
      !botIsAdminBox ||
      isAdminBox ||
      isInWhiteList(groupSettings, threadId, senderId)
    )
      return false;

    const normalizedContent = content.toLowerCase();
    const checkBadWordsResult = checkBadWords(normalizedContent);

    if (checkBadWordsResult.found) {
      try {
        await api.deleteMessage(message, false).catch(console.error);
        const senderName = message.data.dName;
        const senderId = message.data.uidFrom;

        const violation = await saveViolation(
          threadId,
          senderId,
          senderName,
          checkBadWordsResult.word
        );

        let warningMsg = `${senderName} -> Tin nh·∫Øn b·ªã x√≥a v√¨ ch·ª©a t·ª´ ng·ªØ b·ªã c·∫•m: "${checkBadWordsResult.word}"\n`;
        warningMsg += `C·∫£nh c√°o l·∫ßn ${violation.count}/3`;

        if (violation.count >= 3) {
          await extendMuteDuration(
            threadId,
            senderId,
            senderName,
            groupSettings,
            900
          );

          const antiState = getAntiState();
          const violations = {...antiState.data.violations};
          
          if (violations[threadId]?.[senderId]) {
            violations[threadId][senderId].count = 0;
            
            updateAntiConfig({
              ...antiState.data,
              violations
            });
          }

          warningMsg += "\n‚ö†Ô∏è Vi ph·∫°m 3 l·∫ßn, b·∫°n b·ªã c·∫•m chat trong 15 ph√∫t!";
        }

        await api.sendMessage(
          {
            msg: warningMsg,
            quote: message,
            mentions: [MessageMention(senderId, senderName.length, 0)],
            ttl: 30000,
          },
          threadId,
          message.type
        );
        return true;
      } catch (error) {
        console.error("C√≥ l·ªói x·∫£y ra khi anti badword:", error.message);
      }
    }
  }
  return false;
}

// S·ª≠a l·∫°i h√†m showViolationHistory ƒë·ªÉ g·ªôp th√¥ng b√°o
export async function showViolationHistory(api, message, threadId) {
  try {
    const mentions = message.data.mentions;

    if (!mentions || mentions.length === 0) {
      await api.sendMessage(
        {
          msg: "Vui l√≤ng tag (@mention) ng∆∞·ªùi d√πng ƒë·ªÉ xem l·ªãch s·ª≠ vi ph·∫°m.",
          quote: message,
          ttl: 30000,
        },
        threadId,
        message.type
      );
      return;
    }

    const antiState = getAntiState();
    const violations = antiState.data.violations || {};

    let responseMsg = "üìù L·ªãch s·ª≠ vi ph·∫°m:\n\n";
    const messageMentions = [];
    let mentionPosition = responseMsg.length;

    for (const mention of mentions) {
      const userId = mention.uid;
      const userName = message.data.content
        .substr(mention.pos, mention.len)
        .replace("@", "");
      const userViolations = violations[threadId]?.[userId];

      // Th√™m mention v√†o danh s√°ch
      messageMentions.push(
        MessageMention(userId, userName.length, mentionPosition)
      );

      if (!userViolations || userViolations.words.length === 0) {
        responseMsg += `${userName} ch∆∞a c√≥ vi ph·∫°m n√†o.\n\n`;
      } else {
        const countViolations = userViolations.count;
        let recentViolations = "Nh·ªØng vi ph·∫°m g·∫ßn nh·∫•t:\n";
        recentViolations += userViolations.words
          .slice(-3)
          .map(
            (v, i) =>
              `  ${i + 1}. "${v.word}" - ${new Date(v.time).toLocaleString()}`
          )
          .join("\n");

        responseMsg += `${userName}:\n`;
        responseMsg += `S·ªë l·∫ßn vi ph·∫°m: ${countViolations}\n`;
        responseMsg += `${recentViolations}\n`;
      }

      mentionPosition = responseMsg.length;
    }

    await api.sendMessage(
      {
        msg: responseMsg.trim(),
        quote: message,
        ttl: 30000,
      },
      threadId,
      message.type
    );
  } catch (error) {
    console.error("L·ªói khi ƒë·ªçc l·ªãch s·ª≠ vi ph·∫°m:", error);
    await api.sendMessage(
      {
        msg: "ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc l·ªãch s·ª≠ vi ph·∫°m.",
        quote: message,
        ttl: 30000,
      },
      threadId,
      message.type
    );
  }
}

// Th√™m h√†m ki·ªÉm tra v√† x√≥a vi ph·∫°m c≈©
export async function startBadWordViolationCheck() {
  // H·ªßy job c≈© n·∫øu c√≥
  const jobName = "violationCheck";
  const existingJob = schedule.scheduledJobs[jobName];
  if (existingJob) {
    existingJob.cancel();
  }

  // T·∫°o job m·ªõi ch·∫°y m·ªói 5 gi√¢y
  schedule.scheduleJob(jobName, "*/5 * * * * *", async () => {
    try {
      const antiState = getAntiState();
      let hasChanges = false;
      const currentTime = Date.now();
      const VIOLATION_TIMEOUT = 30 * 60 * 1000; // 30 ph√∫t

      const violations = {...antiState.data.violations};

      // Duy·ªát qua t·ª´ng nh√≥m
      for (const threadId in violations) {
        // Duy·ªát qua t·ª´ng ng∆∞·ªùi d√πng trong nh√≥m
        for (const userId in violations[threadId]) {
          const userViolations = violations[threadId][userId];

          // L·ªçc ra c√°c vi ph·∫°m trong v√≤ng 30 ph√∫t
          const recentViolations = userViolations.words.filter((violation) => {
            return currentTime - violation.time < VIOLATION_TIMEOUT;
          });

          // N·∫øu s·ªë l∆∞·ª£ng vi ph·∫°m thay ƒë·ªïi
          if (recentViolations.length < userViolations.words.length) {
            hasChanges = true;
            userViolations.words = recentViolations;

            // C·∫≠p nh·∫≠t l·∫°i s·ªë l·∫ßn vi ph·∫°m
            userViolations.count = recentViolations.length;

            // N·∫øu ƒê√©o c√≤n vi ph·∫°m n√†o, x√≥a user kh·ªèi danh s√°ch
            if (recentViolations.length === 0) {
              delete violations[threadId][userId];
            }
          }
        }

        // N·∫øu ƒê√©o c√≤n user n√†o trong nh√≥m, x√≥a nh√≥m
        if (Object.keys(violations[threadId]).length === 0) {
          delete violations[threadId];
        }
      }

      // L∆∞u l·∫°i n·∫øu c√≥ thay ƒë·ªïi
      if (hasChanges) {
        updateAntiConfig({
          ...antiState.data,
          violations
        });
      }
    } catch (error) {
      console.error("L·ªói khi ki·ªÉm tra vi ph·∫°m:", error);
    }
  });

  console.log(
    chalk.yellow("ƒê√£ kh·ªüi ƒë·ªông schedule ki·ªÉm tra vi ph·∫°m t·ª´ kh√≥a th√¥ t·ª•c")
  );
}
